# ``Collections/PersistentSet``

<!-- DO NOT EDIT THIS FILE; IT'S AUTOMATICALLY GENERATED -->


### Implementation Details

`PersistentSet` and `PersistentDictionary` are based on a Swift adaptation
of the *Compressed Hash-Array Mapped Prefix Tree* (CHAMP) data structure.

- Michael J Steindorfer and Jurgen J Vinju. Optimizing Hash-Array Mapped
   Tries for Fast and Lean Immutable JVM Collections. In *Proc.
   International Conference on Object-Oriented Programming, Systems,
   Languages, and Applications,* pp. 783-800, 2015.
   https://doi.org/10.1145/2814270.2814312

In this setup, the members of such a collection are organized into a tree
data structure based on their hash values. For example, assuming 16 bit hash
values sliced into 4-bit chunks, each node in the prefix tree would have
sixteen slots (one for each digit), each of which may contain a member, a
child node reference, or it may be empty. A `PersistentSet` containing the
three items `Maximo`, `Julia` and `Don Pablo` (with hash values of `0x2B65`,
`0xA69F` and `0xADA1`, respectively) may be organized into a prefix tree of
two nodes:

```
┌0┬1┬2───────┬3┬4┬5┬6┬7┬8┬9┬A──┬B┬C┬D┬E┬F┐
│ │ │ Maximo │ │ │ │ │ │ │ │ • │ │ │ │ │ │
└─┴─┴────────┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─┴─┘
                             ╎
                             ╎
            ┌0┬1┬2┬3┬4┬5┬6───┴──┬7┬8┬9┬A┬B┬C┬D──────────┬E┬F┐
            │ │ │ │ │ │ │ Julia │ │ │ │ │ │ │ Don Pablo │ │ │
            └─┴─┴─┴─┴─┴─┴───────┴─┴─┴─┴─┴─┴─┴───────────┴─┴─┘
```

The root node directly contains `Maximo`, because it is the only set member
whose hash value starts with `8`. However, the first digits of the hashes of
`Julia` and `Don Pablo` are both `A`, so these items reside in a separate
node, one level below the root.

(To save space, nodes are actually stored in a more compact form, with just
enough space allocated to store their contents: empty slots do not take up
any room. Hence the term "compressed" in "Compressed Hash-Array Mapped
Prefix Tree".)

The resulting tree structure lends itself well to sharing nodes across
multiple collection values. Inserting or removing an item in a completely
shared tree requires copying at most log(n) nodes -- every node along the
path to the item needs to be uniqued, but all other nodes can remain shared.
While the cost of copying this many nodes isn't trivial, it is dramatically
lower than the cost of having to copy the entire data structure, like the
standard `Set` has to do.

When looking up a particular member, we descend from the root node,
following along the path specified by successive digits of the member's hash
value. As long as hash values are unique, we will either find the member
we're looking for, or we will know for sure that it does not exist in the
set.

In practice, hash values aren't guaranteed to be unique though. Members with
conflicting hash values need to be collected in special collision nodes that
are able to grow as large as necessary to contain all colliding members that
share the same hash. Looking up a member in one of these nodes requires a
linear search, so it is crucial that such collisions do not happen often.

As long as `Element` properly implements `Hashable`, lookup operations in a
`PersistentSet` are expected to be able to decide whether the set contains a
particular item by looking at no more than a constant number of items on
average -- typically they will need to compare against just one member.

## Topics

### Creating a Set

- ``init()``
- ``init(_:)-6nn9e``
- ``init(_:)-6qbps``
- ``init(_:)-30nei``

### Finding Elements

- ``contains(_:)``
- ``firstIndex(of:)``
- ``lastIndex(of:)``

### Adding and Updating Elements

- ``insert(_:)``
- ``update(with:)``
- ``update(_:at:)``

### Removing Elements

- ``remove(_:)``
- ``remove(at:)``
- ``filter(_:)``

### Non-mutating Set Operations

To acknowledge the efficiency of `PersistentSet` at inserting and removing items
from copies of a set, we provide a family of non-mutating primitives that
perform these operations. Instead of directly modifying the set they're given,
they return a brand new set with the desired result.

- ``inserting(_:)``
- ``updating(with:)``
- ``removing(_:)``

### Combining Sets

All the standard combining operations (intersection, union, subtraction and
symmetric difference) are supported, in both non-mutating and mutating forms.
`SetAlgebra` only requires the ability to combine one set instance with another,
but `PersistentSet` follows the tradition established by `Set` in providing
additional overloads to each operation that allow combining a set with
additional types, including arbitrary sequences.

- ``intersection(_:)-9dx2a``
- ``intersection(_:)-5z4my``
- ``intersection(_:)-1d4e0``

- ``union(_:)-1nk1t``
- ``union(_:)-8otnp``
- ``union(_:)-6eysm``

- ``subtracting(_:)-8sczx``
- ``subtracting(_:)-2iv0a``
- ``subtracting(_:)-63bfb``

- ``symmetricDifference(_:)-76bw``
- ``symmetricDifference(_:)-92ha9``
- ``symmetricDifference(_:)-1n89g``

- ``formIntersection(_:)-4s0od``
- ``formIntersection(_:)-7dqfx``
- ``formIntersection(_:)-8i59p``

- ``formUnion(_:)-68pog``
- ``formUnion(_:)-82rrc``
- ``formUnion(_:)-4r7qz``

- ``subtract(_:)-7rmd3``
- ``subtract(_:)-47r93``
- ``subtract(_:)-3v8ms``

- ``formSymmetricDifference(_:)-499uq``
- ``formSymmetricDifference(_:)-8wue8``
- ``formSymmetricDifference(_:)-4t8jr``

### Comparing Sets

`PersistentSet` supports all standard set comparisons (subset tests, superset
tests, disjunctness test), including the customary overloads established by
`Set`. As an additional extension, the `isEqualSet` family of member functions
generalize the standard `==` operation to support checking whether a
`PersistentSet` consists of exactly the same members as an arbitrary sequence,
ignoring element ordering and duplicates (if any).

- ``==(_:_:)`` 
- ``isEqualSet(to:)-7egih`` 
- ``isEqualSet(to:)-4t0k5`` 
- ``isEqualSet(to:)-7s0cu`` 

- ``isSubset(of:)-9mp7l`` 
- ``isSubset(of:)-2jlh`` 
- ``isSubset(of:)-8vn0j`` 

- ``isSuperset(of:)-5af8o`` 
- ``isSuperset(of:)-6mvxj`` 
- ``isSuperset(of:)-864jy`` 

- ``isStrictSubset(of:)-48nx2`` 
- ``isStrictSubset(of:)-2j680`` 
- ``isStrictSubset(of:)-1s6n9`` 

- ``isStrictSuperset(of:)-nd5j`` 
- ``isStrictSuperset(of:)-5z263``
- ``isStrictSuperset(of:)-ivbh`` 

- ``isDisjoint(with:)-12irx``
- ``isDisjoint(with:)-1hhyf``
- ``isDisjoint(with:)-61lde``
